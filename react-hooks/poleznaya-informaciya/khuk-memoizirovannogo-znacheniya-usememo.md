# Хук мемоизированного значения \(useMemo\)

`useMemo` предназначен для оптимизации и возвращает мемоизированное значение.

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

Передайте «создающую» функцию и массив зависимостей. Если массив не был передан, новое значение будет вычисляться при каждом рендере. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

`useCallback` получает на функцию и массив аргументов, и возвращает одну и туже функцию, до тех пор, пока аргументы не изменились. `useMemo` отличается тем, что он возвращает не саму функцию, а результат её выполнения. По большому счету они являются взаимозаменямыми.  
 Таким образом, `useMemo` используется для сохранения результатов тяжёлых вычислений, например обработка массива.

```jsx
const data = useMemo(() => array.map(mapper).filter(predicate).reduce(reducer), [array])
```

Помните, что функция, переданная `useMemo`, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат `useEffect`, а не `useMemo`.

